#!/bin/bash

BASEDIR="$HOME/.config/fdcli"

TOKEN=`cat $BASEDIR/TOKEN || echo`
ORG=`cat $BASEDIR/ORG || echo`

APIURL=https://$TOKEN@api.flowdock.com

### utilities

wait_jobs() {
    for job in `jobs -p`
    do
        wait $job
    done
}

http() {
    log curl "$@"
    curl -s --fail -A 'fdcli <github.com/rwos/fdcli>' "$@"
}

log() {
    echo "`date`	$@" >> "$BASEDIR/fdcli.log"
}

logpipe() {
    while read line
    do
        echo "`date`	STDERR: $line" >> "$BASEDIR/fdcli.log"
    done
}

json() {
    local prog=`echo "$@"`
    python -c "import json,sys,codecs;u=codecs.getwriter('utf8');sys.stdout=u(sys.stdout);OUT=sys.stdout.write;J=json.load(sys.stdin);$prog"
} 2> >(logpipe)

json_to_db() {
    local prog=""
    for field in "$@"
    do
        prog+="OUT('$field' + '\t');"
    done
    prog+="OUT('\n'); ["
    for field in "$@"
    do
    prog+="OUT(x.get('$field', False).replace('\\n', '\\\\n').replace('\\t', '\\\\t') if isinstance(x.get('$field', False), basestring) else str(x.get('$field', False))) or OUT('\t') or "
    done
    prog+='OUT("\n") for x in J]'
    json $prog
} 2> >(logpipe)

chunk() {
    local len=72 ##### XXX should be maximum 72, but do use $1
    #### XXX hack needed so that fold doesn't remove newlines(???)
    local in=`cat`
    if [ `echo "$in" | wc -c` -lt $len ]
    then
        echo "$in"
    else
        echo "$in" | fold -w $len -s
    fi
} 2> >(logpipe)

### api

api_get() {
    local path=$1
    http $APIURL$path
} 2> >(logpipe)

api_test_connection() {
    log testing connection to flowdock
    http $APIURL/organizations/$ORG > /dev/null || (
        echo fdcli: FATAL: Cannot connect to Flowdock
        echo Please make sure you have your personal API token in $BASEDIR/TOKEN
        echo and the name of your organization in $BASEDIR/ORG
        echo
        echo Get the API token on https://www.flowdock.com/account/tokens
        echo
    )
}

### local database

db() {
    echo $BASEDIR/${1}.db
}

db_store() {
    cat > `db $1`
} 2> >(logpipe)

db_get() {
    cat `db $1`
} 2> >(logpipe)

db_select() {
    local db=$1
    shift
    local fieldspec=""
    for field in "$@"
    do
        local fieldnum=`db_get $db | head -n 1 | \
                    tr '\t' '\n' | fgrep -xn $field | \
                    cut -d ':' -f 1 | tr -d '\n'`
        fieldspec+="\$$fieldnum \"\t\" "
    done
    db_get $db | tail -n +2 | awk -F '\t' "{ print $fieldspec ;}" | head -c -1
} 2> >(logpipe)

db_where() {
    local id=$1
    awk -F '\t' "{ if (\$1 == \"$id\") { \$1=\"\"; print \$0; }}"
}

db_join() {
    local db=$1
    local id_field=$2
    local data_field=$3
    db_format 1 "db_select $db $id_field $data_field | db_where %s"
}

db_format() {
    local field=$1
    local prog_template=$2
    while read line
    do
        local orig=`echo "$line" | cut -d '	' -f $field`
        local prog="`printf "$prog_template" "$orig"`"
        local new="`eval "$prog"`"
        echo "$line" | awk -F '\t' "{ OFS=\"	\"; \$$field=\"$new\"; print }"
    done
}

db_print() {
    local awkspec=$1
    awk -F '\t' "{ print $awkspec;}"
}

db_update_users() {
    log updating users
    api_get /organizations/$ORG/users | json_to_db id nick name email | db_store users
} 2> >(logpipe)

db_update_flows() {
    log updating flows
    api_get /flows/all | json_to_db id parameterized_name name description joined | db_store flows
} 2> >(logpipe)

db_update_private() {
    log updating private chats
    api_get /private | json_to_db id name open | db_store private
} 2> >(logpipe)

db_store_messages() {
    # ordered by date, newest first
    local db_name=${1}.messages
    local in=`cat`
    local car=`echo "$in" | head -n 1`
    local cdr=`echo "$in" | tail -n +2 | sort -r -n -t "	" -k 2 | uniq`

    log storing `echo "$cdr" | wc -l` new messages "for" ${1}

    local tmp=`mktemp`
    touch `db $db_name`
    (echo "$car"; echo "$cdr"; db_get $db_name | tail -n +2) > $tmp

    local car=`cat $tmp | head -n 1`
    local cdr=`cat $tmp | tail -n +2 | sort -r -n -t "	" -k 2 | uniq`
    (echo "$car"; echo "$cdr") > `db $db_name`
    rm -f $tmp
} 2> >(logpipe)

db_update_latest_messages() {
    local flow_name=$1
    local since_id=`db_select ${flow_name}.messages id | head -n 1`
    if [ $since_id ]
    then
        log updating messages after $since_id "for" $flow_name
        api_get "/flows/$ORG/$flow_name/messages?limit=100&since_id=$since_id" | json_to_db id sent event thread_id user tags content | db_store_messages ${flow_name}
    else
        log getting last few messages "for" $flow_name
        api_get /flows/$ORG/$flow_name/messages?limit=100 | json_to_db id sent event thread_id user tags content | db_store_messages ${flow_name}
    fi
} 2> >(logpipe)

### user interface

UIDIR=`mktemp -d`
HMARK="┄"
VMARK="║"

UIW=0
UIH=0

LAYOUT_FLOWS_W=30
LAYOUT_FLOWS_H=60

ui_buffer() {
    echo "$UIDIR/$1"
}

ui_buffer_store() {
    log ui buffer store `ui_buffer $1`
    cat > `ui_buffer $1`
} 2> >(logpipe)

ui_buffer_display() {
    local name=$1
    local x=$2
    local y=$3
    local w=$4
    local h=$5

    local cur_line=0

    log display $name x=$x y=$y w=$w h=$h
    touch `ui_buffer $name`
    ### XXX TODO: clear rectangle of area, remove clear in redraw => redraw single buffers
    while read line
    do
        printf -- "$line" | chunk $w | head -n 1
    done < `ui_buffer $name` | \
        while read line
        do
            if [ $cur_line -lt $(($h - 1)) ]
            then
                tput cup $(($y + $cur_line)) $x
                printf -- "$line"
            fi
            cur_line=$(($cur_line + 1))
        done
} 2> >(logpipe)

bold=`tput bold`
special=`tput setab 5`
tput_name=`tput setab 3; tput setaf 0`
off=`tput sgr0`

underline=`tput smul`
offunderline=`tput rmul`

ui_render_message() {
    echo "$1" | sed \
        -e "s/https\\?:[^[:space:]]\+/$underline\0$offunderline/g" \
        -e "s/:[^[:space:]]\+:/$special\0$off/g" \
        -e "s/@[^[:space:]]\+:/$bold\0$off/g"
} 2> >(logpipe)

ui_buffer_display_messages() {
    local name="messages"
    local x=$1
    local y=$2
    local w=$3
    local h=$4
    ##### XXX this doesn't work right

    local cur_line=0

    log display $name x=$x y=$y w=$w h=$h
    touch `ui_buffer $name`
    ### XXX TODO: clear rectangle of area, remove clear in redraw => redraw single buffers
    cat `ui_buffer $name` | sed 's/\\n/\n/g' | while read line
    do
        printf -- "$line" | chunk $w
        printf "\n"
    done | \
        while read line ### XXX this destroys empty newlines?
        do
            #log "MSG LINE $line" # XXX
            if [ $cur_line -lt $(($h - 1)) ]
            then
                tput cup $(($y + $cur_line)) $x
                printf -- "$line"
            fi
            cur_line=$(($cur_line + 1))
        done
} 2> >(logpipe)

ui_buffer_vmark() {
    local x=$1
    local y=$2
    local h=$3

    tput setaf 2
    for l in `seq $h`
    do
        tput cup $(($y + $l - 1)) $x
        printf "$VMARK"
    done
    tput sgr0
} 2> >(logpipe)

ui_buffer_hmark() {
    local x=$1
    local y=$2
    local w=$3

    tput setaf 2
    for c in `seq $w`
    do
        tput cup $y $(($x + $c -1))
        printf "$HMARK"
    done
    tput sgr0
} 2> >(logpipe)

ui_resize() {
    UIW=`tput cols`
    UIH=`tput lines`
    log resize UIW=$UIW UIH=$UIH
    ui_redraw
}

ui_redraw() {
#### XXX TODO: hide cursor, but only here
    local fw=$(LANG=C printf "%.0f" $(bc <<< "scale=5; ($UIW/100)*$LAYOUT_FLOWS_W"))
    local fh=$(LANG=C printf "%.0f" $(bc <<< "scale=5; ($UIH/100)*$LAYOUT_FLOWS_H"))
    log redraw fw=$fw fh=$fh
    tput clear
    ui_buffer_display flows 0 0 $fw $fh
    ui_buffer_display private 0 $(($fh + 1)) $fw $(($UIH - $fh))
    ui_buffer_display flowtitle $(($fw + 2)) 0 $(($UIW - $fw - 2)) 2
    ui_buffer_display_messages $(($fw + 2)) 4 $(($UIW - $fw - 2)) $((UIH - 4))
    ui_buffer_vmark $fw 0 $UIH
    ui_buffer_hmark 0 $fh $fw
    # go back to input field
    tput cup 1 $(($fw + 2))
} 2> >(logpipe)

CURRENT_FLOW=devlounge
ui_update_buffers() {
    ### XXX XXX TODO: selection + callback trigger for each buffer
    db_select flows joined name | db_where True | sort | ui_buffer_store flows &
    db_select private open name | db_where True | sort | ui_buffer_store private &
    db_select flows parameterized_name name description | db_where ${CURRENT_FLOW} | tr '\t' '\n' | ui_buffer_store flowtitle &
    db_select ${CURRENT_FLOW}.messages user sent content | head -n 50 | \
        db_join users id nick | \
        db_format 1 'printf "${bold}%s${off}"' | \
        db_format 2 'date -R -d "@$((%s / 1000))" | cut -d " " -f 2,3,4,5' | \
        db_format 3 'ui_render_message "%s"' | \
        db_print '$1" "$2" "$3' | ui_buffer_store messages &
    wait_jobs
} 2> >(logpipe)

ui_init() {
    tput smcup
    trap "tput rmcup; tput sgr0" EXIT
    #### XXX https://bugzilla.redhat.com/show_bug.cgi?id=1197768
    trap "ui_resize" WINCH
    ui_resize
}

### main

#### XXX REORDER
MAIN() {
    mkdir -p "$BASEDIR"
    echo > "$BASEDIR/fdcli.log"

    log hello world
    api_test_connection

    ui_init

    ui_update_buffers
    ui_redraw

    #db_update_users &
    #db_update_flows &
    #db_update_private &
    wait_jobs

    ### XXX only update flow buffer, and do so right after db_update_flows, etc.
    ui_update_buffers
    ui_redraw

    joined=`db_select flows joined parameterized_name | db_where True`
    for flow in $joined
    do
        echo 
        #db_update_latest_messages $flow &
    done
    wait_jobs

    ui_update_buffers
    ui_redraw

    while read -r input
    do
        ### TODO: parse \n as a newline
        ### TODO: backspace destroys the line - maybe read char by char?
        echo "POST '$input'"
    done
    exit
}

MAIN
