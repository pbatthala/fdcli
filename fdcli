#!/bin/bash

BASEDIR="$HOME/.config/fdcli"

mkdir -p "$BASEDIR"
echo > "$BASEDIR/fdcli.log"

TOKEN=`cat $BASEDIR/TOKEN || echo`
ORG=`cat $BASEDIR/ORG || echo`

APIURL=https://$TOKEN@api.flowdock.com

### utilities

http() {
    log curl "$@"
    curl -s --fail -A 'fdcli <github.com/rwos/fdcli>' "$@"
}

error() {
    echo "fdcli: error: $@" 1>&2
    exit 1
}
log() {
    echo "`date`	$@" >> "$BASEDIR/fdcli.log"
}

json() {
    local prog=`echo "$@"`
    python -c "import json,sys,codecs;u=codecs.getwriter('utf8');sys.stdout=u(sys.stdout);OUT=sys.stdout.write;J=json.load(sys.stdin);$prog" \
        || error "while" parsing JSON
}

json_to_db() {
    local prog=""
    for field in "$@"
    do
        prog+="OUT('$field' + '\t');"
    done
    prog+="OUT('\n'); ["
    for field in "$@"
    do
    prog+="OUT(x.get('$field', False).replace('\\n', '\\\\n').replace('\\t', '\\\\t') if isinstance(x.get('$field', False), basestring) else str(x.get('$field', False))) or OUT('\t') or "
    done
    prog+='OUT("\n") for x in J]'
    json $prog
}

chunk() {
    local len=$1
    ### XXX FIXME: how can this be _that_ slow?
    perl -CS -e "{@x=<>=~/(\\X{1,$len})/g;foreach(@x){print \"\$_\\n\";}}"
}

### api

api_get() {
    local path=$1
    http $APIURL$path || error "while" trying to GET $APIURL$path
}

### local database

db() {
    echo $BASEDIR/${1}.db
}

db_store() {
    cat > `db $1`
}

db_get() {
    cat `db $1` 2> /dev/null
}

db_select() {
    local db=$1
    shift
    local fieldspec=""
    for field in "$@"
    do
        fieldspec+=`db_get $db | head -n 1 | \
                    tr '\t' '\n' | fgrep -xn $field | \
                    cut -d ':' -f 1 | tr -d '\n' 2>/dev/null`,
    done
    db_get $db | tail -n +2 | cut -f ${fieldspec:0:-1} 2>/dev/null
}

db_update_users() {
    log updating users
    api_get /organizations/$ORG/users | json_to_db id nick name email | db_store users
}

db_update_flows() {
    log updating flows
    api_get /flows/all | json_to_db id parameterized_name name description joined | db_store flows
}

db_update_private() {
    log updating private chats
    api_get /private | json_to_db id name open | db_store private
}

db_store_messages() {
    # ordered by date, newest first
    local db_name=${1}.messages
    local in=`cat`
    local car=`echo "$in" | head -n 1`
    local cdr=`echo "$in" | tail -n +2 | sort -r -n -t "	" -k 2 | uniq`

    log storing `echo "$cdr" | wc -l` new messages "for" ${1}

    local tmp=`mktemp`
    touch `db $db_name`
    (echo "$car"; echo "$cdr"; db_get $db_name | tail -n +2) > $tmp

    local car=`cat $tmp | head -n 1`
    local cdr=`cat $tmp | tail -n +2 | sort -r -n -t "	" -k 2 | uniq`
    (echo "$car"; echo "$cdr") > `db $db_name`
    rm -f $tmp
}

db_update_latest_messages() {
    local flow_name=$1
    local since_id=`db_select ${flow_name}.messages id | head -n 1`
    if [ $since_id ]
    then
        log updating messages after $since_id "for" $flow_name
        api_get "/flows/$ORG/$flow_name/messages?limit=100&since_id=$since_id" | json_to_db id sent event thread_id user tags content | db_store_messages ${flow_name}
    else
        log getting last few messages "for" $flow_name
        api_get /flows/$ORG/$flow_name/messages?limit=100 | json_to_db id sent event thread_id user tags content | db_store_messages ${flow_name}
    fi
}

### user interface

UIDIR=`mktemp -d`

ui_buffer() {
    echo "$UIDIR/$1"
}

ui_buffer_store() {
    cat > `ui_buffer $1`
}

ui_buffer_display() {
    local name=$1
    local x=$2
    local y=$3
    local w=$4
    local h=$5
    local word_wrap=$6

    local cur_line=0

    log display $name x=$x y=$y w=$w h=$h word_wrap=$word_wrap
    while read line
    do
        if [ $word_wrap ]
        then
            printf -- "$line" | chunk $w | head -n 1
        else
            printf -- "$line" | chunk $w
        fi
    done < `ui_buffer $name` | \
        while read line
        do
            if [ $cur_line -lt $h ]
            then
                tput cup $cur_line $x
                printf -- "$line"
                tput cup $cur_line $(($x + $w))
                printf "|"
            fi
            cur_line=$(($cur_line + 1))
        done
}

### main

test_connection() {
    log testing connection to flowdock
    http $APIURL/organizations/$ORG > /dev/null || (
        echo fdcli: FATAL: Cannot connect to Flowdock
        echo Please make sure you have your personal API token in $BASEDIR/TOKEN
        echo and the name of your organization in $BASEDIR/ORG
        echo
        echo Get the API token on https://www.flowdock.com/account/tokens
        echo
    )
}

echo "fdcli: info: logging to $BASEDIR/fdcli.log"
log hello

#test_connection XXX RE-ENABLE

db_select flows name joined | awk -F '\t' '{ if ($2 == "True") print $1;}' | sort | ui_buffer_store flows
db_select private name open | awk -F '\t' '{ if ($2 == "True") print $1;}' | sort | ui_buffer_store private

### XXX
### XXX TODO: make db_join which handles the sorting
###           XXX-> but how would we restore the original sorting?
### XXX or better: look up user
#db_select devlounge.messages user content | head -n 50 | sort -n | join - `db users`;exit # | ui_buffer_store messages

tput clear
ui_buffer_display flows 0 0 10 6 0
ui_buffer_display private 15 0 15 6 0
#ui_buffer_display messages 23 0 40 60 0
exit

db_update_users &
db_update_flows &
db_update_private &
for job in `jobs -p`
do
    wait $job
done

joined=`db_select flows parameterized_name joined | awk -F '\t' '{ if ($2 == "True") print $1;}'`
for flow in $joined
do
    db_update_latest_messages $flow &
done
for job in `jobs -p`
do
    wait $job
done
